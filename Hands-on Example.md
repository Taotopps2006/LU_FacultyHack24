### **Comprehensive Hands-On Project: Bash-Based Server Management Application**

---

## **Project Title:**
**BashServerManager** – An All-in-One Bash-Based Server Management Application

## **Objective:**
Develop a robust, Bash-scripted application named **BashServerManager** that automates the setup, monitoring, management, and security of a Linux-based server. This application will integrate key operating system concepts such as process management, CPU scheduling, memory management, storage management, and advanced security measures, providing students with a practical, hands-on experience.

---

## **Project Overview**

**BashServerManager** is a centralized Bash application that offers a menu-driven interface to perform various server administration tasks. The application will encompass the following functionalities:

1. **System Setup and Configuration**
2. **Process and CPU Management**
3. **Memory Monitoring and Optimization**
4. **Storage Management and Backup**
5. **Security and Protection**
6. **Virtualization and Distributed Systems Integration**
7. **Advanced Monitoring and Logging**

Each module will incorporate relevant operating system concepts and Bash scripting techniques covered in the course.

---

## **Project Structure**

Organize the project directory as follows:

```
BashServerManager/
├── scripts/
│   ├── setup_system.sh
│   ├── process_manager.sh
│   ├── memory_monitor.sh
│   ├── storage_manager.sh
│   ├── security_setup.sh
│   ├── virtualization_manager.sh
│   ├── monitoring_logger.sh
│   └── bash_server_manager.sh
├── config/
│   └── config.cfg
├── logs/
│   └── server_manager.log
├── README.md
└── LICENSE
```

- **scripts/**: Contains all individual Bash scripts.
- **config/**: Holds configuration files.
- **logs/**: Stores log files generated by the application.
- **README.md**: Documentation and usage instructions.
- **LICENSE**: Licensing information.

---

## **Detailed Project Components**

### **1. System Setup and Configuration**

**Objective:**
Automate the installation of essential packages, configure system settings, and customize the Bash environment.

**Key Concepts:**
- Operating system structures
- Linux basic commands
- Shell customization

**Script: `setup_system.sh`**

```bash
#!/bin/bash

# setup_system.sh - Automate system setup and configuration

# Function to install essential packages
install_packages() {
    echo "Installing essential packages..."
    PACKAGES=(git vim curl htop ufw)
    for pkg in "${PACKAGES[@]}"; do
        sudo apt-get install -y "$pkg"
        if [ $? -ne 0 ]; then
            echo "Failed to install $pkg" | tee -a ../logs/server_manager.log
        else
            echo "$pkg installed successfully." | tee -a ../logs/server_manager.log
        fi
    done
    echo "Package installation completed."
}

# Function to configure Bash environment
configure_bash() {
    echo "Configuring Bash environment..."
    # Add aliases
    echo "alias ll='ls -la'" >> ~/.bashrc
    echo "alias gs='git status'" >> ~/.bashrc

    # Customize prompt
    echo "export PS1='\u@\h \w\$ '" >> ~/.bashrc

    # Source the updated .bashrc
    source ~/.bashrc

    echo "Bash environment configured." | tee -a ../logs/server_manager.log
}

# Execute functions
install_packages
configure_bash

echo "System setup and configuration completed successfully." | tee -a ../logs/server_manager.log
```

**Explanation:**
- **Package Installation:** Installs a list of essential packages using `apt-get`. Logs success or failure for each package.
- **Bash Configuration:** Adds useful aliases and customizes the Bash prompt by appending to `~/.bashrc`. Reloads the Bash configuration.

---

### **2. Process and CPU Management**

**Objective:**
Monitor active processes, manage process priorities, and ensure critical services are running.

**Key Concepts:**
- Processes and threads
- CPU scheduling algorithms
- Process management system calls

**Script: `process_manager.sh`**

```bash
#!/bin/bash

# process_manager.sh - Manage and monitor processes and CPU usage

# Function to display top CPU-consuming processes
show_top_processes() {
    echo "Top 10 CPU-consuming processes:"
    ps aux --sort=-%cpu | head -n 11
}

# Function to adjust process priority
adjust_priority() {
    read -p "Enter PID of the process to renice: " PID
    read -p "Enter new nice value (e.g., 10): " NICE_VALUE
    if [[ "$NICE_VALUE" =~ ^-?[0-9]+$ ]]; then
        sudo renice -n "$NICE_VALUE" -p "$PID"
        if [ $? -eq 0 ]; then
            echo "Successfully changed nice value of PID $PID to $NICE_VALUE."
        else
            echo "Failed to change nice value for PID $PID."
        fi
    else
        echo "Invalid nice value entered."
    fi
}

# Function to ensure critical services are running
ensure_service() {
    read -p "Enter the name of the service to monitor (e.g., apache2): " SERVICE
    if systemctl is-active --quiet "$SERVICE"; then
        echo "Service '$SERVICE' is running."
    else
        echo "Service '$SERVICE' is not running. Attempting to start..."
        sudo systemctl start "$SERVICE"
        if systemctl is-active --quiet "$SERVICE"; then
            echo "Service '$SERVICE' started successfully."
        else
            echo "Failed to start service '$SERVICE'."
        fi
    fi
}

# Menu for process management
echo "Process and CPU Management Menu:"
echo "1. Show Top CPU-Consuming Processes"
echo "2. Adjust Process Priority"
echo "3. Ensure Critical Service is Running"
echo "4. Return to Main Menu"
read -p "Select an option: " OPTION

case $OPTION in
    1) show_top_processes ;;
    2) adjust_priority ;;
    3) ensure_service ;;
    4) exit 0 ;;
    *) echo "Invalid option selected." ;;
esac
```

**Explanation:**
- **Show Top Processes:** Displays the top 10 processes consuming the most CPU.
- **Adjust Priority:** Allows the user to change the nice value of a specific process, affecting its CPU scheduling priority.
- **Ensure Service:** Checks if a critical service (e.g., `apache2`) is running and attempts to start it if not.

---

### **3. Memory Monitoring and Optimization**

**Objective:**
Continuously monitor memory usage, send alerts for high usage, and manage swap space to optimize memory.

**Key Concepts:**
- Main memory and virtual memory
- Memory management system calls
- Page replacement algorithms

**Script: `memory_monitor.sh`**

```bash
#!/bin/bash

# memory_monitor.sh - Monitor memory usage and optimize

LOG_FILE="../logs/server_manager.log"
THRESHOLD=80  # Memory usage threshold in percentage

# Function to check memory usage and send alert
check_memory_usage() {
    USED=$(free | grep Mem | awk '{print ($3/$2) * 100.0}')
    USED_INT=${USED%.*}
    if [ "$USED_INT" -gt "$THRESHOLD" ]; then
        echo "$(date): Memory usage is above $THRESHOLD% - Currently at $USED%" | tee -a "$LOG_FILE"
        # Send alert (e.g., email) - Requires mailutils or similar setup
        # echo "Memory usage is high: $USED%" | mail -s "Memory Alert" user@example.com
    fi
}

# Function to manage swap space
manage_swap() {
    read -p "Do you want to toggle swap space? (y/n): " CHOICE
    if [ "$CHOICE" = "y" ] || [ "$CHOICE" = "Y" ]; then
        echo "Disabling swap..."
        sudo swapoff -a
        echo "Swap disabled." | tee -a "$LOG_FILE"
        sleep 5
        echo "Enabling swap..."
        sudo swapon -a
        echo "Swap enabled." | tee -a "$LOG_FILE"
    else
        echo "Swap management skipped." | tee -a "$LOG_FILE"
    fi
}

# Monitoring loop
echo "Starting memory monitoring. Press [CTRL+C] to stop."
while true; do
    check_memory_usage
    sleep 60  # Check every 60 seconds
done
```

**Explanation:**
- **Memory Check:** Periodically checks memory usage. If usage exceeds the threshold (80%), logs the event and can send an alert (e.g., via email).
- **Swap Management:** Provides an option to toggle swap space, which can help in optimizing memory usage by freeing up or re-enabling swap.

---

### **4. Storage Management and Backup**

**Objective:**
Monitor disk usage, perform regular backups of important directories, and ensure filesystem integrity.

**Key Concepts:**
- Storage structure and file systems
- I/O systems
- Filesystem management system calls

**Scripts:**

#### **a. `storage_manager.sh`**

```bash
#!/bin/bash

# storage_manager.sh - Manage storage and perform backups

# Function to display disk usage
display_disk_usage() {
    echo "Disk Usage Report:"
    df -h
    echo ""
    echo "Top 10 Largest Directories:"
    du -ah / | sort -rh | head -n 10
}

# Function to perform backup
perform_backup() {
    SOURCE_DIR="/home/user/data"
    BACKUP_DIR="/home/user/backup"
    TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
    BACKUP_FILE="$BACKUP_DIR/data_backup_$TIMESTAMP.tar.gz"

    mkdir -p "$BACKUP_DIR"
    tar -czf "$BACKUP_FILE" "$SOURCE_DIR" >> ../logs/server_manager.log 2>&1
    if [ $? -eq 0 ]; then
        echo "Backup completed successfully at $TIMESTAMP." | tee -a ../logs/server_manager.log
    else
        echo "Backup failed at $TIMESTAMP." | tee -a ../logs/server_manager.log
    fi
}

# Function to check filesystem integrity
check_filesystem() {
    read -p "Enter the filesystem to check (e.g., /dev/sda1): " FS
    sudo fsck -Af -M "$FS" >> ../logs/server_manager.log 2>&1
    if [ $? -eq 0 ]; then
        echo "Filesystem check completed for $FS." | tee -a ../logs/server_manager.log
    else
        echo "Filesystem check failed for $FS." | tee -a ../logs/server_manager.log
    fi
}

# Menu for storage management
echo "Storage Management Menu:"
echo "1. Display Disk Usage"
echo "2. Perform Backup"
echo "3. Check Filesystem Integrity"
echo "4. Return to Main Menu"
read -p "Select an option: " OPTION

case $OPTION in
    1) display_disk_usage ;;
    2) perform_backup ;;
    3) check_filesystem ;;
    4) exit 0 ;;
    *) echo "Invalid option selected." ;;
esac
```

**Explanation:**
- **Disk Usage Report:** Displays overall disk usage and lists the top 10 largest directories to identify space hogs.
- **Backup:** Creates a compressed backup of a specified directory, appending a timestamp to the backup filename. Logs the outcome.
- **Filesystem Check:** Allows the user to perform a filesystem integrity check using `fsck`.

---

### **5. Security and Protection**

**Objective:**
Secure the server by managing file permissions, configuring firewall rules, and setting up secure SSH access.

**Key Concepts:**
- Protection mechanisms
- Security best practices
- System calls related to security

**Scripts:**

#### **a. `security_setup.sh`**

```bash
#!/bin/bash

# security_setup.sh - Configure system security

LOG_FILE="../logs/server_manager.log"

# Function to set file permissions and ownership
set_permissions() {
    DIRECTORY="/var/www/html"
    sudo chmod -R 755 "$DIRECTORY"
    sudo chown -R www-data:www-data "$DIRECTORY"
    echo "Permissions and ownership set for $DIRECTORY." | tee -a "$LOG_FILE"
}

# Function to configure firewall using ufw
configure_firewall() {
    echo "Configuring firewall using UFW..."
    sudo ufw default deny incoming
    sudo ufw default allow outgoing
    sudo ufw allow ssh
    sudo ufw allow http
    sudo ufw allow https
    sudo ufw enable
    echo "Firewall rules updated and UFW enabled." | tee -a "$LOG_FILE"
}

# Function to manage SSH keys
manage_ssh_keys() {
    SSH_DIR="$HOME/.ssh"
    KEY_FILE="$SSH_DIR/id_rsa"

    if [ ! -f "$KEY_FILE" ]; then
        mkdir -p "$SSH_DIR"
        ssh-keygen -t rsa -b 4096 -f "$KEY_FILE" -N ""
        echo "SSH key pair generated." | tee -a "$LOG_FILE"
    else
        echo "SSH key already exists." | tee -a "$LOG_FILE"
    fi
}

# Menu for security setup
echo "Security and Protection Menu:"
echo "1. Set File Permissions and Ownership"
echo "2. Configure Firewall (UFW)"
echo "3. Manage SSH Keys"
echo "4. Return to Main Menu"
read -p "Select an option: " OPTION

case $OPTION in
    1) set_permissions ;;
    2) configure_firewall ;;
    3) manage_ssh_keys ;;
    4) exit 0 ;;
    *) echo "Invalid option selected." ;;
esac
```

**Explanation:**
- **Set Permissions:** Adjusts permissions and ownership for a specific directory, ensuring that web files are securely accessible.
- **Configure Firewall:** Uses UFW (Uncomplicated Firewall) to set default policies, allow necessary ports (SSH, HTTP, HTTPS), and enable the firewall.
- **Manage SSH Keys:** Generates SSH key pairs if they do not exist, enhancing secure remote access.

---

### **6. Virtualization and Distributed Systems Integration**

**Objective:**
Manage virtual machines and deploy Docker containers for application isolation, as well as perform distributed system operations.

**Key Concepts:**
- Virtual machines and hypervisors
- Containers and Docker
- Distributed system operations

**Scripts:**

#### **a. `virtualization_manager.sh`**

```bash
#!/bin/bash

# virtualization_manager.sh - Manage virtual machines and Docker containers

# Function to manage VirtualBox VMs using VBoxManage
manage_virtualbox_vm() {
    VM_NAME="TestVM"
    echo "VirtualBox VM Management:"
    echo "1. Start VM"
    echo "2. Stop VM"
    echo "3. Check VM Status"
    echo "4. Return"
    read -p "Select an option: " VM_OPTION

    case $VM_OPTION in
        1)
            VBoxManage startvm "$VM_NAME" --type headless
            echo "VM '$VM_NAME' started." | tee -a ../logs/server_manager.log
            ;;
        2)
            VBoxManage controlvm "$VM_NAME" poweroff
            echo "VM '$VM_NAME' stopped." | tee -a ../logs/server_manager.log
            ;;
        3)
            VBoxManage showvminfo "$VM_NAME" | grep -i "State"
            ;;
        4)
            return
            ;;
        *)
            echo "Invalid option selected."
            ;;
    esac
}

# Function to manage Docker containers
manage_docker_container() {
    IMAGE="nginx:latest"
    CONTAINER_NAME="web_server"

    echo "Docker Container Management:"
    echo "1. Start Container"
    echo "2. Stop Container"
    echo "3. Check Container Status"
    echo "4. Return"
    read -p "Select an option: " DOCKER_OPTION

    case $DOCKER_OPTION in
        1)
            if [ "$(docker ps -q -f name=$CONTAINER_NAME)" ]; then
                echo "Container '$CONTAINER_NAME' is already running."
            else
                docker run -d --name "$CONTAINER_NAME" -p 80:80 "$IMAGE"
                echo "Docker container '$CONTAINER_NAME' started." | tee -a ../logs/server_manager.log
            fi
            ;;
        2)
            docker stop "$CONTAINER_NAME"
            echo "Docker container '$CONTAINER_NAME' stopped." | tee -a ../logs/server_manager.log
            ;;
        3)
            docker ps -f name="$CONTAINER_NAME"
            ;;
        4)
            return
            ;;
        *)
            echo "Invalid option selected."
            ;;
    esac
}

# Function to perform distributed operations
distributed_operations() {
    SERVERS=("server1" "server2" "server3")  # Replace with actual server hostnames or IPs
    COMMAND="uptime"

    echo "Executing distributed command: $COMMAND"
    for SERVER in "${SERVERS[@]}"; do
        ssh user@"$SERVER" "$COMMAND" &
    done
    wait
    echo "Distributed command execution completed." | tee -a ../logs/server_manager.log
}

# Menu for virtualization and distributed systems
echo "Virtualization and Distributed Systems Menu:"
echo "1. Manage VirtualBox VMs"
echo "2. Manage Docker Containers"
echo "3. Execute Distributed Operations"
echo "4. Return to Main Menu"
read -p "Select an option: " OPTION

case $OPTION in
    1) manage_virtualbox_vm ;;
    2) manage_docker_container ;;
    3) distributed_operations ;;
    4) exit 0 ;;
    *) echo "Invalid option selected." ;;
esac
```

**Explanation:** (This is optional)
- **VirtualBox VM Management:** Provides options to start, stop, and check the status of a VirtualBox virtual machine using `VBoxManage`.
- **Docker Container Management:** Allows users to start, stop, and check the status of a Docker container (e.g., an Nginx web server).
- **Distributed Operations:** Executes a command (`uptime`) concurrently on multiple remote servers via SSH, demonstrating basic distributed system operations.

---

### **7. Advanced Monitoring and Logging**

**Objective:**
Implement comprehensive monitoring of system resources and maintain detailed logs for auditing and troubleshooting.

**Key Concepts:**
- Monitoring tools and techniques
- Logging mechanisms
- Integration with other system components

**Script: `monitoring_logger.sh`**

```bash
#!/bin/bash

# monitoring_logger.sh - Advanced monitoring and logging

LOG_FILE="../logs/server_manager.log"

# Function to log system metrics
log_system_metrics() {
    echo "Logging system metrics..."
    {
        echo "=== $(date) ==="
        echo "CPU Usage:"
        top -bn1 | grep "Cpu(s)"
        echo ""
        echo "Memory Usage:"
        free -h
        echo ""
        echo "Disk Usage:"
        df -h
        echo ""
        echo "Top Processes by CPU:"
        ps aux --sort=-%cpu | head -n 11
        echo ""
    } >> "$LOG_FILE"
}

# Function to set up system monitoring (e.g., via cron)
setup_cron_job() {
    CRON_JOB="*/5 * * * * /path/to/monitoring_logger.sh"
    (crontab -l ; echo "$CRON_JOB") | crontab -
    echo "Cron job set to log system metrics every 5 minutes." | tee -a "$LOG_FILE"
}

# Menu for advanced monitoring
echo "Advanced Monitoring and Logging Menu:"
echo "1. Log Current System Metrics"
echo "2. Set Up Automated Monitoring"
echo "3. View Log File"
echo "4. Return to Main Menu"
read -p "Select an option: " OPTION

case $OPTION in
    1) log_system_metrics ;;
    2) setup_cron_job ;;
    3) less "$LOG_FILE" ;;
    4) exit 0 ;;
    *) echo "Invalid option selected." ;;
esac
```

**Explanation:**
- **Log System Metrics:** Captures CPU, memory, and disk usage, along with top CPU-consuming processes, and appends the data to a log file with timestamps.
- **Set Up Automated Monitoring:** Adds a cron job to execute the logging script every 5 minutes, ensuring continuous monitoring.
- **View Log File:** Allows users to view the log file for auditing and troubleshooting purposes.

---

### **8. Master Script: `bash_server_manager.sh`**

**Objective:**
Provide a centralized, menu-driven interface to access all functionalities of **BashServerManager**.

**Script: `bash_server_manager.sh`**

```bash
#!/bin/bash

# bash_server_manager.sh - Master script for BashServerManager

# Ensure the log directory exists
mkdir -p logs

# Function to display the main menu
show_main_menu() {
    echo "======================================"
    echo "       BashServerManager Menu         "
    echo "======================================"
    echo "1. System Setup and Configuration"
    echo "2. Process and CPU Management"
    echo "3. Memory Monitoring and Optimization"
    echo "4. Storage Management and Backup"
    echo "5. Security and Protection"
    echo "6. Virtualization and Distributed Systems"
    echo "7. Advanced Monitoring and Logging"
    echo "8. Exit"
    echo "======================================"
}

# Main loop
while true; do
    show_main_menu
    read -p "Select an option [1-8]: " MAIN_OPTION
    echo ""

    case $MAIN_OPTION in
        1)
            ./scripts/setup_system.sh
            ;;
        2)
            ./scripts/process_manager.sh
            ;;
        3)
            ./scripts/memory_monitor.sh
            ;;
        4)
            ./scripts/storage_manager.sh
            ;;
        5)
            ./scripts/security_setup.sh
            ;;
        6)
            ./scripts/virtualization_manager.sh
            ;;
        7)
            ./scripts/monitoring_logger.sh
            ;;
        8)
            echo "Exiting BashServerManager. Goodbye!"
            exit 0
            ;;
        *)
            echo "Invalid option. Please select a number between 1 and 8."
            ;;
    esac
    echo ""
done
```

**Explanation:**
- **Main Menu:** Displays a clear, user-friendly menu with options corresponding to each module of the application.
- **Loop:** Continuously prompts the user for input until they choose to exit.
- **Integration:** Calls the respective scripts based on user selection, ensuring seamless integration of all functionalities.

---

## **Project Integration and Workflow**

1. **Setup:**
   - Ensure all scripts are executable:
     ```bash
     chmod +x scripts/*.sh
     ```
   - Update the `PATH` or navigate to the project directory to execute the master script.

2. **Running the Application:**
   - Execute the master script:
     ```bash
     ./scripts/bash_server_manager.sh
     ```
   - Navigate through the menu to access different functionalities.

3. **Logging:**
   - All significant actions and alerts are logged in `logs/server_manager.log` for auditing and troubleshooting.

4. **Scheduling:**
   - Use the **Advanced Monitoring and Logging** module to set up automated logging via cron jobs.

---

## **Evaluation Criteria**

Students will be assessed based on the following:

1. **Functionality:**
   - All modules perform their intended tasks correctly.
   - The master script integrates all components seamlessly.

2. **Code Quality:**
   - Scripts are well-organized, readable, and properly commented.
   - Efficient use of Bash features and best practices.

3. **Automation and Reliability:**
   - Automated scripts handle errors gracefully.
   - Scheduled tasks run reliably without manual intervention.

4. **Security:**
   - Proper file permissions and security measures are implemented.
   - Sensitive operations are secured (e.g., SSH keys, firewall rules).

5. **Documentation:**
   - Comprehensive `README.md` explaining project overview, setup instructions, and usage guidelines.
   - Inline comments within scripts explaining key sections and commands.

---

## **Submission Requirements**

1. **Source Code:**
   - All Bash scripts organized in the `scripts/` directory.
   
2. **Configuration Files:**
   - Any necessary configuration files placed in the `config/` directory.

3. **Log Files:**
   - Ensure the `logs/` directory captures logs generated during operations.

4. **Documentation:**
   - A `README.md` file detailing the project overview, setup instructions, and usage guidelines.
   - Example:
     ```markdown
     # BashServerManager

     ## Overview
     BashServerManager is an all-in-one Bash-based application designed to automate the setup, monitoring, management, and security of a Linux-based server environment.

     ## Features
     - System setup and configuration
     - Process and CPU management
     - Memory monitoring and optimization
     - Storage management and backup
     - Security and protection
     - Virtualization and distributed systems integration
     - Advanced monitoring and logging

     ## Setup Instructions
     1. Clone the repository:
        ```bash
        git clone https://github.com/yourusername/BashServerManager.git
        ```
     2. Navigate to the project directory:
        ```bash
        cd BashServerManager
        ```
     3. Make all scripts executable:
        ```bash
        chmod +x scripts/*.sh
        ```
     4. Run the master script:
        ```bash
        ./scripts/bash_server_manager.sh
        ```

     ## Usage
     - Follow the on-screen menu to access different functionalities.
     - Refer to individual scripts for detailed operations.

     ## Logging
     - All logs are stored in the `logs/server_manager.log` file.

---

## **Learning Outcomes**

By completing the **BashServerManager** project, students will:

- **Integrate Knowledge:** Apply theoretical concepts of operating systems in practical scenarios using Bash.
- **Develop Scripting Skills:** Enhance proficiency in writing robust and efficient Bash scripts.
- **Understand System Administration:** Gain hands-on experience in managing and securing Linux systems.
- **Problem-Solve:** Tackle real-world system administration challenges through automation and scripting.
- **Collaborate and Document:** Learn to document and present technical solutions effectively.

---

## **Conclusion**

The **BashServerManager** project provides a comprehensive, hands-on application that encapsulates all the key operating system concepts discussed in the course. By developing this application, students will not only reinforce their understanding of Bash scripting but also gain valuable experience in Linux system administration, preparing them for real-world challenges in IT and DevOps roles.

---